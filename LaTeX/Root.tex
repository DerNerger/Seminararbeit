\chapter{Das Framework PandaRoot}
Der Track-Cleaner wurde innerhalb des Frameworks PandaRoot entwickelt und getestet. Aus diesem Grund wird nun zunächst das verwendete Framework eingeführt, sodass in späteren Kapiteln die Implementation des Track-Cleaners besser nachvollzogen werden kann. Das verwendete Framework PandaRoot ist Teil des übergeordneten Frameworks FairRoot. FairRoot verwendet wiederum das Framework Root und baut darauf auf. Deshalb wird im Folgenden zunächst Root erläutert um im späteren Verlauf des Kapitels die spezielleren Frameworks zu thematisieren.

\section{ROOT}
Um Experimente aus dem Bereich der Hochenergiephysik simulieren zu können, wurde am CERN das objektorientierte Framework ROOT in C++ entwickelt. Prinzipiell ist ROOT aber auch für zahlreiche, darüber hinausgehende Anwendungsfälle einsetzbar. Bei ROOT handelt es sich um ein extrem vielseitiges Framework, welches einige Schnittstellen zur Modifikation und Erweiterung bietet. Zum wesentlichen Funktionsumfang gehören die folgenden Funktionalitäten \cite{Root_Linux}:
\begin{enumerate}
	\item Erstellen von Histogrammen (2D und 3D)
	\item Data management
	\item Streudiagramme
	\item Erstellen von Graphen
	\item Fitten von Funktionen
	\item Statistische Datenanalyse
	\item Mathematische Standard-Funktionen
	\item 3D-Visualisierung
	\item Grafik-Export
\end{enumerate} 
Zur Simulation von komplexen Systemen wie \pnd{} besitzt ROOT die Schnittstelle VirtualMC. Diese Kapselt den Zugriff auf den eigentlichen Simulationsalgorithmus, sodass dieser bei Bedarf einfach ausgetauscht werden kann. Für \pnd{} wird dazu Geant3 bzw. 4 verwendet. Dabei kommen verschiedene Strategien zum Einsatz. Beispielsweise würde die im vorangegangenen Kapitel erwähnte Bahnkurve eines geladenen Teilchens im Magnetfeld mittels Lösen von Bewegungsgleichungen simuliert werden. Andererseits wird bei der Simulation von stark zufallsbasierten Ereignissen, wie der Zerfall eines Teilchens, ein stochastischer Ansatz zu Grunde gelegt.  \cite[S. 16]{MasterJette}

\subsection{Root-Dateien}
Zur persistenten Speicherung von Daten werden in Root baumartig strukturierte Dateien verwendet, sogenannte Root-Dateien. In diesen Dateien können die verschiedenen Algorithmen einen Branch anlegen und eigene Daten darin Speichern. Ein anderer Algorithmus kann diese Branches dann öffnen um auf die Dateien zugreifen zu können. Ein Trackfinding-Algorithmus schreibt üblicherweise die rekonstruierten Tracks ebenfalls in eine Root-Datei. Der TrackCleaner soll die zu bereinigenden Tracks ebenfalls aus einer Root-Datei lesen und die bereinigten Tracks in diese Datei schreiben.

Zusammenfassend lässt sich feststellen, dass ROOT über eine große Anzahl bereits implementierter Funktionalität verfügt, auf welche bei der Simulation von \pnd{} zurückgegriffen werden kann. Des Weiteren bietet ROOT eine breite Schnittstelle zur Erweiterung und Anpassung der Funktionalität, wodurch der für \pnd{} benötigte Code leicht ins Framework integriert werden kann.

\section{FairRoot}
Da ROOT zur Entwicklung und Simulation weiter Teile von FAIR eingesetzt wird, ist es sinnvoll hier ein gemeinsames Programmiergerüst anzulegen.
FairRoot stellt ein Gerüst von Basisklassen zur Verfügung, die von den jeweiligen Experimenten durch Ableiten an eigene Bedürfnisse angepasst werden können. Daraus ergibt sich der Vorteil, dass einheitliche Datenstrukturen verwendet werden und somit eine korrekte Kommunikation verschiedener Algorithmen möglich ist. Beispielsweise existiert in FairRoot die Klasse FairHit. Diese enthält unter anderem Position, Fehler und DetektorID und stellt eine Abstraktion eines rekonstruierten Hits dar. Damit ist ein FairHit im gesamten FairRoot-Framework gültig und bekannt. Durch Vererbung ist es des Weiteren möglich, im untergeordneten Framework PandaRoot eine spezialisierte Version eines FairHits zu erstellen. Hier existiert beispielsweise die Klasse PndSttHit, welche die Klasse FairHit um einige Attribute wie TubeID oder Isochronenradius erweitert. Alle Klassennamen, welche zu FairRoot gehören beginnen mit Fair.

\section{PandaRoot}
Aus den im vorangegangenen Abschnitt bereits erläuterten Gründen macht es ebenfalls Sinn, alle Klassen welche im Rahmen des \pnd{}-Experiments von Relevanz sind in einem Framework zusammenzufassen. Das Framework PandaRoot stellt ein einheitliches Programmgerüst für das \pnd{}-Experiment bereit und basiert auf FairRoot und somit auch transitiv auf Root. Alle Klassen, welche für das \pnd{}-Experiment relevant sind beginnen mit Pnd und werden in PandaRoot zusammengefasst. Der Simulationsprozess von PandaRoot lässt sich in 5 Teilprozesse separieren, welche im Folgenden erläutert werden. Die Kenntnis darüber, wie der Simulationsprozess genau funktioniert, ist für die Entwicklung des Track-Cleaners von besonderem Interesse. Es ist notwendig, vor dem Einsatz des Track-Cleaners alle vorher benötigten Simulationsschritte durchzuführen um die Daten zu erzeugen, welche dem Track-Cleaner als Eingabe dienen.

\subsection{Der Simulationsprozess von PandaRoot}
Es ist üblich, Root im Batchbetrieb über Macros zu steuern. Diese Macros beinhalten C++-Code, der mittels des in Root integrierten Interpreters Cint ausgeführt werden kann. Hierbei ist es sinnvoll verschiedene Teilprozesse der Simulation in unterschiedlichen Macros zu definieren. Dies ist nicht zwingend erforderlich, aber durchaus empfehlenswert, da beispielsweise mit den selben simulierten Teilchenflugbahnen mehrere Rekonstruktionsversuche durchgeführt werden sollen. Der Simulationsprozess von PandaRoot wird üblicherweise wie folgt aufgeteilt:

\begin{enumerate}
	\item Generieren von Events
	\item Transport
	\item Digitalisierung
	\item Rekonstruktion
	\item Analyse
\end{enumerate}

Im ersten Schritt werden die in der weiterführenden Simulation benötigten Events definiert bzw. generiert. Hierfür kommen sogenannte Event-Generatoren zum Einsatz. Ein Event-Generator erzeugt benötigte Informationen wie Energie und Impuls der entstandenen Teilchen. Der Event-Generator dient also zur Definition und zur Simulation der primären physikalischen Reaktion des Beamteilchens mit dem Target. Damit eine große Vielfalt physikalisch verschiedener Experimente simuliert werden kann, gibt es verschiedene Event-Generatoren. Beispielsweise erlaubt der Event-Generator EvtGen die Definition von komplexen Zerfallsketten, welche bei der Simulation des Experiments verwendet werden sollen. Die vom Event-Generator erzeugten Teilchen dienen dem sich anschließenden Transport-Modell als Eingabe. Dabei werden unter Berücksichtigung der vom Event-Generator erzeugten Werte die Flugbahnen der Teilchen simuliert. Dabei kommen Monte-Carlo-Programme wie Geant zum Einsatz, welche unter Berücksichtigung der Detektorgeometrie Monte-Carlo-Punkte erzeugen. Diese Punkte kennzeichnen die Stellen, an denen ein Teilchen das Detektormaterial durchquert hat. Außerdem werden Effekte berücksichtigt, welche entstehen können, wenn die Teilchen mit dem Detektormaterial wechselwirken. In der nun folgenden Digitalisierung wird die Hit-Erfassung des Detektorsystems simuliert. Damit ist gemeint, dass genau die Messwerte erstellt werden, welche von den Detektoren gemessen werden, wenn die simulierten Teilchen an den Monte-Carlo-Punkten das Detektormaterial durchdringen. Hierbei werden auch Messungenauigkeiten mit einbezogen. Somit ergibt es sich, dass die von der Digitalisierung erzeugten Hits meistens nicht auf den Monte-Carlo-Punkten, sondern an den Positionen der entsprechenden Detektorkomponente liegen. Beim STT werden Hits grundsätzlich genau in der Mitte einer Straw Tube ausgelöst. Es kann ebenfalls zu dem Fall kommen, dass kein Hit erzeugt wird, obwohl ein Teilchen den Detektor passiert hat. Dies ist beispielsweise der Fall, wenn das eingehende Signal nicht stark genug ist, um den für einen Hit nötigen Grenzwert zu überschreiten. Die bisher genannten Vorgänge werden nur bei der Entwicklung und Simulation des Detektors ausgeführt und werden später durch ein reales Experiment ersetzt. Die sich nun anschließende Rekonstruktion beinhaltet alle Programmteile, welche später auch zur Rekonstruktion des realen Experiments eingesetzt werden. Dazu werden die aus Digitalisierung oder Experiment gewonnenen Daten von vielen verschiedene Teilprogrammen ausgewertet und analysiert. Zu diesen Teilprogrammen zählen Trackfinder, Fitting-Algorithmen wie beispielsweise der Riemann-Fit und der im Rahmen dieser Arbeit entwickelte Track-Cleaner. Zum Schluss werden die Teilergebnisse der einzelnen Subdetektoren zu den globalen Tracks zusammengefasst, welche von der Rekonstruktion als Ausgabe produziert werden. Im Anschluss daran wird eine physikalische Analyse der rekonstruierten Daten ausgeführt. Dabei werden rekonstruierte Teilchen und Events genauer untersucht und ermittelt, aus welcher primären Reaktion die gemessenen Sekundärteilchen hervorgegangen sind.

\subsection{Qualitätskontrolle}

Im Anschluss an den Simulationsprozess sollte eine Kontroll-Task ausgeführt werden, welche die Qualität der Rekonstruierten Tracks überprüft. Bei der Qualitätskontrolle kann auf die vorher simulierten physischen Tracks zurückgegriffen werden. Soll beispielsweise überprüft werden, ob ein Trackfinding-Algorithmus einen Track fehlerfrei rekonstruiert hat, können die dem Track zugeordneten Hits zu den Monte-Carlo-Punkten und schließlich zum Monte-Carlo-Track zurückverfolgt werden. Verweisen alle gefundenen Hits auf den selben Monte-Carlo-Track liegt ein fehlerfrei rekonstruierter Track vor. Eine Task zur Qualitätskontrolle ist folglich auch nur bei simulierten Daten sinnvoll, da bei einem realen Experiment keine Daten über die physischen Tracks vorliegen, welche als Referenz benutzt werden können. Darüber hinaus können, aufgrund der Analyse vieler verschiedener Events, in der Analyse-Task auch Statistiken erstellt werden um die Effektivität des zu überprüfenden Algorithmus grafisch zu veranschaulichen. \cite[S. 16-19]{MasterJette}